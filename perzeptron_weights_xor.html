<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Perceptron</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            gap: 30px;
        }

        .controls {
            width: 250px;
        }

        .controls h2 {
            margin-top: 0;
        }

        label {
            display: block;
            margin-top: 15px;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="number"] {
            width: 70px;
            padding: 4px;
            margin-right: 6px;
            box-sizing: border-box;
        }

        canvas {
            border: 1px solid black;
            background: #f9f9f9;
        }

        .value {
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="controls">
    <h2>Perceptron Parameters - XOR</h2>

    <label>
        Weight w₁:
        <span class="value" id="w1Value">1</span>
        <input type="range" id="w1" min="-5" max="5" step="0.1" value="1">
    </label>

    <label>
        Weight w₂:
        <span class="value" id="w2Value">1</span>
        <input type="range" id="w2" min="-5" max="5" step="0.1" value="1">
    </label>

    <label>
        Bias b:
        <span class="value" id="bValue">0</span>
        <input type="range" id="b" min="-5" max="5" step="0.1" value="0">
    </label>

    <fieldset style="margin-top:12px; padding:8px; border:1px solid #ddd;">
        <legend style="font-weight:bold">Points (x, y)</legend>

        <label>Point A (Circle, class 0):
            <input type="number" id="p0x" step="0.1" value="-1"> 
            <input type="number" id="p0y" step="0.1" value="-1">
        </label>

        <label>Point B (Cross, class 1):
            <input type="number" id="p1x" step="0.1" value="-1"> 
            <input type="number" id="p1y" step="0.1" value="1">
        </label>

        <label>Point C (Cross, class 1):
            <input type="number" id="p2x" step="0.1" value="1"> 
            <input type="number" id="p2y" step="0.1" value="-1">
        </label>

        <label>Point D (Circle, class 0):
            <input type="number" id="p3x" step="0.1" value="1"> 
            <input type="number" id="p3y" step="0.1" value="1">
        </label>
    </fieldset>

    <p>
        Activation function:<br>
        <strong>step(w₁·x₁ + w₂·x₂ + b)</strong><br>
        → 1 (blue), 0 (red)
    </p>
</div>
<div height="500">
    <canvas id="plot" width="500" height="500"></canvas>
</div>
<script>
    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    const w1Slider = document.getElementById("w1");
    const w2Slider = document.getElementById("w2");
    const bSlider = document.getElementById("b");

    const w1Value = document.getElementById("w1Value");
    const w2Value = document.getElementById("w2Value");
    const bValue = document.getElementById("bValue");

    // point input elements
    const p0x = document.getElementById("p0x");
    const p0y = document.getElementById("p0y");
    const p1x = document.getElementById("p1x");
    const p1y = document.getElementById("p1y");
    const p2x = document.getElementById("p2x");
    const p2y = document.getElementById("p2y");
    const p3x = document.getElementById("p3x");
    const p3y = document.getElementById("p3y");

    const scale = 50; // pixels per unit
    const originX = canvas.width / 2;
    const originY = canvas.height / 2;

    function step(x) {
        return x >= 0 ? 1 : 0;
    }

    function getPointsFromInputs() {
        function v(el) { const n = parseFloat(el.value); return isNaN(n) ? 0 : n; }
        return [
            { x: v(p0x), y: v(p0y), label: 0 },
            { x: v(p1x), y: v(p1y), label: 1 },
            { x: v(p2x), y: v(p2y), label: 1 },
            { x: v(p3x), y: v(p3y), label: 0 }
        ];
    }

    function drawTicks() {
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;

    const tickSize = 6;

    // X-axis ticks at x = -1 and x = +1
    [-1, 1].forEach(v => {
        const px = originX + v * scale;
        ctx.beginPath();
        ctx.moveTo(px, originY - tickSize);
        ctx.lineTo(px, originY + tickSize);
        ctx.stroke();
    });

    // Y-axis ticks at y = -1 and y = +1
    [-1, 1].forEach(v => {
        const py = originY - v * scale;
        ctx.beginPath();
        ctx.moveTo(originX - tickSize, py);
        ctx.lineTo(originX + tickSize, py);
        ctx.stroke();
    });
}
    
    function draw() {
        const w1 = parseFloat(w1Slider.value);
        const w2 = parseFloat(w2Slider.value);
        const b = parseFloat(bSlider.value);

        w1Value.textContent = w1;
        w2Value.textContent = w2;
        bValue.textContent = b;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw decision regions
        for (let px = 0; px < canvas.width; px += 4) {
            for (let py = 0; py < canvas.height; py += 4) {
                const x = (px - originX) / scale;
                const y = (originY - py) / scale;

                const output = step(w1 * x + w2 * y + b);
                ctx.fillStyle = output === 1
                    ? "rgba(0, 100, 255, 0.15)"
                    : "rgba(255, 0, 0, 0.15)";
                ctx.fillRect(px, py, 4, 4);
            }
        }

        // Draw axes
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, originY);
        ctx.lineTo(canvas.width, originY);
        ctx.moveTo(originX, 0);
        ctx.lineTo(originX, canvas.height);
        ctx.stroke();

        drawTicks();
        ctx.font = "12px Arial";
        ctx.fillStyle = "black";
        
        // X labels
        [-1, 1].forEach(v => {
            const px = originX + v * scale;
            ctx.fillText(v.toString(), px - 4, originY + 18);
        });
        
        // Y labels
        [-1, 1].forEach(v => {
            const py = originY - v * scale;
            ctx.fillText(v.toString(), originX + 8, py + 4);
        });
        
        // Read datapoints from the input fields
        const points = getPointsFromInputs();

        // Draw data points
        points.forEach(point => {
            const px = originX + point.x * scale;
            const py = originY - point.y * scale;

            if (point.label === 1) {
                // Draw Cross Marker for +1
                ctx.strokeStyle = "blue";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(px - 6, py - 6);
                ctx.lineTo(px + 6, py + 6);
                ctx.moveTo(px + 6, py - 6);
                ctx.lineTo(px - 6, py + 6);
                ctx.stroke();
            } else {
                // Draw Circle Marker for 0
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, 2 * Math.PI);
                ctx.stroke();
            }
        });

        // Draw decision boundary: w1*x1 + w2*x2 + b = 0
        if (w2 !== 0) {
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();

            const x1 = -canvas.width / scale;
            const y1 = -(w1 * x1 + b) / w2;

            const x2 = canvas.width / scale;
            const y2 = -(w1 * x2 + b) / w2;

            ctx.moveTo(originX + x1 * scale, originY - y1 * scale);
            ctx.lineTo(originX + x2 * scale, originY - y2 * scale);
            ctx.stroke();
        }


    }

    w1Slider.addEventListener("input", draw);
    w2Slider.addEventListener("input", draw);
    bSlider.addEventListener("input", draw);
    [p0x,p0y,p1x,p1y,p2x,p2y,p3x,p3y].forEach(el => el.addEventListener('input', draw));

    draw();
</script>

</body>
</html>


